# C语言复习
[TOC]
## 一、绪论
1. 反码：正数的反码和正数的原码相同，负数的反码其符号位为1，其余各位逐位取反，即0
变为1，1变为0。
2. 补码：正数的补码与正数的原码相同，负数的补码等于负数的反码加1。
3. 采用补码表示，可以把减法运算变成加法运算，其结果亦为补码表示。
4. 8位二进制数补码所能表示的数的范围是-128 ~+127。
5. 一个C程序可以由若干个函数构成，其中必须有且只能有一个以main命名的主函数。C语言运行时从main函数头部开始，到main函数最后结束。
6. C函数是一个独立的程序块，相互不能嵌套。
7. 标识符的组成规则 :由字母(A~Z，a~z)、下划线和数字(0~9)组成，其第一个字符为字母或下划线。字母区分大小写。
8. 能够被编译程序识别的标识符的字符的数目称为标识符的有效长度。标准C规定标识符的有效长度为31（DOS环境下）。
9. 关键字： auto break case char const continue default do double else enum extern
float for goto if Int long register return short signed sizeof static struct switch typedef union
unsigned void volatile while
10. 分隔符: 包括空格符、制表符、换行符、换页符。程序中两个相邻的标识符、关键字和常量之间必须用分隔符分开(通常用空格符)。
11. 以’\’打头后跟一个字母或数字的部分称为换码序列(转义字符)。
12. 输入数据时，遇到下列情况时该数据认为结束：a.遇空格、回车或者tab键b.遇宽度结束，如“%3d”只取输入项前三列。

## 二、数据类型、运算符和表达式
1. 整型常量的后缀：长整型数是用后缀“L”或“l”来表示的。如：158L (十进制为158),012L (十进制为10)

2. a.一个浮点数可以无整数部分或小数部分，但不能二者全无；b.一个浮点数可以无小数点或指数部分，但不能二者全无。

3. 指数形式：[±] [整数部分] [.] [小数部分] [(e,E)±n] [后缀]如：-1.23456e+4

4. 字符型常量:用单引号括起来的一个字符 ，单引号中的内容不能是单引号，双引号和反斜线。字符常量的值就是该字符的ASCII码值。一个字符常量在内存中只占一个字节。

5. 广义地讲，C语言字符集中的任何一个字符均可用转义字符来表示。

6. 注意ASCII表的八进制表示\ddd与十六进制表示\xhh。

7. 注意：`\0` `\000` `\x00`均`==`0。

8. 字符常量由单引号括起来，字符串常量由双引号括起来。字符常量只能是单个字符，字符串常量则可以含一个或多个字符。可以把一个字符常量赋予一个字符串变量，但不能把一个字符串常量赋予一个字符变量。字符常量占一个字节的内存空间。字符串常量占的内存字节数等于字符串中字符数加1。增加的一个字节中存放字符’\0’ (ASCII码为0)。这是字符串结束的标志。

9. float型变量仅能接收实型常量的7位有效数字，在有效数字后面输出的数字都是
    不准确的，double型变量可以接收实型常量的16位有效数字。

10. 正上溢趋向于正无穷，负上溢趋向于负无穷。

11. 无论什么表达式，都会返回一个结果(或值)。

12. %运算符要求运算量必须是整型，且%后面的运算量不能为0。

13. 当双目运算符的两个操作数的类型不同时，运算前遵循类型的一般转换规则将运算量自动转换成相同的类型，运算结果的类型与转换后的运算量的类型相同。

14. `%hu`输出无符号短整数。

15. ![image-20210107203609982](C:\Users\62728\AppData\Roaming\Typora\typora-user-images\image-20210107203609982.png)

16. 1) 对于逻辑与（&&）运算,若左表达式为“假”，则无需判断右表达式的值即可以断定逻辑表达式的值为假；只有当左表达式为“真”时,才需要继续判断右表达式。2) 对于逻辑或（||）运算，当左
    表达式为“真”时，则无需判断右表达式的值即可以断定逻辑表达式的值为真；只有当左表达为“假”时,才需要继续判断右表达式。
    总之，如果当整个逻辑表达式能由前部分决定，其后部分可不再计算！

17. 自增自减运算符为单目运算符。自增自减运算符只能作用于变量，不能用于常量
    和表达式。

18. `x++`先用后变，`++x`先变后用。

19. 赋值`=`是双目运算符。

20. 多重赋值表达式从右向左进行。例：`i = j = 10` 这是一个多重赋值表达式，赋值运算符按从右至左结合，即相当于`i=( j=10)`,先将10赋给j,而括号中的赋值表达式（j=10）的值就是赋值后的y的值,再将其赋给i。

21. 复合赋值运算符是在赋值运算符“ = ”前加上其他运算符构成。C语言中
    的复合赋值运算符有10种：`+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`|=`、`^=`、`<<=`、`>>=`。其表达式形式为：左值表达式 op= 右值表达式等价于 左值表达式 = 左值表达式 op 右值表达式。

22. 一般形式：表达式1 ? 表达式2 : 表达式3
	操作过程：判断表达式1的值，如果为非0值，则求解表达式2的值，并将其作为该条件表达式的值；如果表达式1的值为0，则求解表达式3的值，并将其作为该条件表达式的值。
	
23. 逗号运算符是双目运算符，用它构成的逗号表达式形式为：表达式1 , 表达式2 , 表达式3, …… , 表达式n
	运算过程：先求表达式1的值，然后再求表达式2的值，依次计算下去，最后表达式n的值也就是该逗号表达式的值。
	
24. `&`：按位与运算是对两个操作数逐位“求与”。![image-20210107205539649](C:\Users\62728\AppData\Roaming\Typora\typora-user-images\image-20210107205539649.png)

    作用：（1）将某些位清零。

    ​					操作过程：将一个数的后四位清零，即让它与11……10000按位与。

    ​			（2）取数中的特殊位。

    ​					操作过程：保留一个数的后四位而其他数清零，即让它与00……01111按位与。

25. `|`：按位或运算：对两个操作数逐位“相或”。![image-20210107210038655](C:\Users\62728\AppData\Roaming\Typora\typora-user-images\image-20210107210038655.png)

      作用：（1）将一个数的某些位置变1.

      ​					操作过程：将一个数的后四位变为1，即让它与00……01111按位或。

      ​			（2）将一个二进制数接到另外一个二进制数后面。

      ​					操作过程：前后交错，别的位补0，进行按位或。

26. `^`：按位异或运算：将两个操作数逐位“相异或”。![image-20210107210601379](C:\Users\62728\AppData\Roaming\Typora\typora-user-images\image-20210107210601379.png)

    某位要保持不变就异或0，某位要取反就异或1。
    
    作用：不引入其他变量实现两个数的交换。`a=a^b;b=b^a;a=a^b;`
    
27. `<<`：二进制左移运算符
	把数据向左移动若干位,移出左边界的所有位都将丢失，右侧新增加的位为0。
	
28. `>>`：二进制右移运算符
	二进制右移运算符把数据向右移动若干位,移出右边界的所有位都将丢失,左侧的新位的补充遵循下面的规则：(1) 对于无符号数,右移时左侧的新位一律补0,称为“逻辑右移”；(2) 对于有符号数,若符号位是0,则左侧新位一律补0；若符号位是1,则左侧新位一律补1,称为“算术右移”。
	
29. `~`：按位取反运算符
	按位取反运算符是将操作数进行逐位“取反”。
	
30. 无论是自动类型转换还是强制类型转换，都只是将变量或常量的值的类型进行暂时的转换，用于参与运算和操作，而变量和常量本身的类型和数值并没有改变。

31. ![image-20210107211732657](C:\Users\62728\AppData\Roaming\Typora\typora-user-images\image-20210107211732657.png)

32. ![image-20210107211754331](C:\Users\62728\AppData\Roaming\Typora\typora-user-images\image-20210107211754331.png)

     （1）%md，m为指定的输出字段的最小宽度。如果数据的位数小于m，则左端补以空格，若大于m，则按实际位数输出。

     （2）%ms，输出的字符串占m列，如字符串本身长度大于m，则突破m的限制，将字符串全部输出。若串长小于m，则左补空格。

     （3）%-ms，如果串长小于m，则在m列范围内，字符串向左靠，右补空格。

     （4）%m.ns，输出占m列，但只取字符串中左端n个字符。这n个字符输出在m列的右侧，左补空格。

     （5）%-m.ns，其中m、n含义同上，n个字符输出在m列范围的左侧，右补空格。如果n>m，则m自动取n值，即保证n个字符正常输出。

     注意：如果只有n没有m则对输出的位数没有要求。

     （6）%m.nf，指定输出的数据共占m列，其中有n位小数，输出数据右靠齐。如果数值长度小于m，则左端补空格。

     注意：小数点也算在m列之内。若m小于实际位数，则不起作用。若n大于实际小数点位数，则计算机自动补全。注意舍去小数点后几位时会四舍五入。

33. ![image-20210107213452347](C:\Users\62728\AppData\Roaming\Typora\typora-user-images\image-20210107213452347.png)

     （1）对unsigned型变量所需的数据，可以用%u，%d或%o，%x格式输入。

     （2）如果在%后有一个“*”附加说明符，表示跳过指定的列数。

     （3）输入数据时不能规定精度。

## 三、程序和流程控制

1. 语句是程序的基本元素，程序中的各功能部分都是由一定含义的语句组成的，换句话说，语句是一个完整程序的基本组成部分。

2. C语句的特点是以分号为结束符。

3. 根据语句的作用可以把语句分成说明语句和执行语句两大类。

   说明语句：用来对程序中所使用的各种类型变量及属性进行说明，按其所起作用有时也称为定义语句。

   执行语句：一般包含四大类，表达式语句(包括空语句)、复合语句、流程控制语句、辅助控制语句。

   （1）表达式语句：任何一个表达式加上一个分号就是一条语句，一般的格式为：表达式；//表达式语句
   		  只有分号而没有表达式的语句就叫空语句；空语句格式为：； //空语句

   ​	      注意：空语句也是可以存在的。

   （2）复合语句： 将若干语句用括号{ }括起来就构成了复合语句，复合语句在语法上相当于一个语句。

4. 结构化程序的三种基本结构：顺序结构、选择结构、循环结构。
	顺序结构：即按序进行。
	选择结构：即if语句，由两分支选择结构可以派生出另一种基本结构，多分支选择结构。
	循环结构：在给定条件成立的情况下，反复执行某个程序段。有当型循环结构和直到型循环结构。
5. 程序执行过程的C语言描述就是我们所编写的程序的主体。
6. 流程控制语句：选择`if else`、`switch`循环`for`、`while`、`do while`。
   辅助控制语句：控制语句`break`、`continue`、`goto`、`return`。
7. if(x) 等价于 if(x!=0)，if(!x) 等价于 if(x==0)。
8. 如变量x为float等实型变量，则与零值比较的标准if语句如下：if (fabs(x)<= 1e-6 )
   浮点0与整数0的区别：前者是一个逼近0的区间范围[-a,a]，其大小由具体应用的精度要求决定，所以`float a=1.0;a=1;`可能表示错误，后者是一个单一的0值。
9. switch语句复习。
```c
switch(表达式){
	case 判断值1:
	语句组1;
	break;
	case 判断值2:
	语句组2;
	break;
	……
	case 判断值 n:
	语句组n;
	break;
	default:
	语句组n+1;
	break;
}
```
注意：（1）switch ( )后面圆括号中的表达式要求结果是整数(整形变量)，各个case的判断值要求是整型常量。

​			（2）多个分支语句组的break语句起着退出switch-case结构的作用，若无此语句，程序将顺序执行下一个case语句组。

​			（3）各个case和default及其下面的语句组的顺序是任意的，但各个case后面的判断值必须是不同的值。

10. for语句的表达式1，表达式2和表达式3可以全部或部分省掉，但是分号不能省，相当于永真条件（条件永远成立），即for( ; ; )等同于 for( ; 1 ; )，此种情况下，必须在循环体中使用break来控制循环的结束。
11. for语句的循环体可以是空的，大括号也可以不写。
12. 能用while循环和for循环描述的程序大多数情况下都能用do-while循环描述；能用do-while循环描述的程序一定能用while循环和for循环描述。
13. 程序中使用goto语句时要求和标号配合，一般形式：
```c
goto 标号;
…………
标号: 语句;
```
14. 程序设计典型模板：多项式累计法、显式条件试数法、隐式条件处理法。

## 四、函数

1. 程序的执行总是从主函数开始。主函数中的所有语句按先后顺序执行完，则程序执行结束。

2. 函数的存储类型说明只有static（静态）和extern（外部）两种 。存储类型为static时，对函数的调用局限于所在文件；存储类型为extern时，可省略，表示此函数是外部函数，可供其他文件调用。

3. 函数的数据类型是函数返回值的数据类型，可以是各种基本数据类型（char、int、double等）和复杂数据类型，包括指针类型和结构体。当函数的数据类型为int时，可省略。

4. C语言中可以定义参数数目可变的函数。定义参数数目可变的函数时，必须至少明确说明一个形参；在列出的最后一个形参后面用省略符（.....）来说明该函数的参数数目可变。

5. 对于在程序运行期间根据需要进行临时动态分配存储空间的变量称为“动态存储变量”；对于在程序运行期间永久性占用内存的变量称为“静态存储变量"。

6. 存储类型包括:auto 自动型、register 寄存器型、extern 外部参照型、static 静态型。

7. auto：在函数内或复合语句中定义自动型变量时auto可缺省，即平时的各种int都是auto型的。

8. register：寄存器型变量，寄存器型变量在函数内或复合语句内定义，现代编译器有能力自动把普通变量优化为寄存器变量，并且可以忽略用户的指定，所以一般无需特别声明变量为register。

9. extern：一般用于在程序的多个编译单位之传送数据，在这种情况下指定为extern型的变量是其它编译单位的源程序中定义的，它的存储空间在静态数据区，在程序执行过程中长期占用空间。要访问另一个文件中定义的跨文件作用域的全局变量，必须进行extern说明。

   使用方法：多个源文件中共享使用同一个全局变量时，需要在一个地方定义一次，其它地方多次声明extern，才可使用。

10. static：静态型变量既可以在函数或复合语句内进行，也可以在所有函数之外进行。在函数或复合语句内部定义的静态变量称为局部静态变量，在函数外定义的静态变量称为全局静态变量。

    static变量拥有全局寿命，但可见性受局部和全局影响。

    在外部函数内定义的静态型变量的值再二次调用该外部函数时有记忆性，而auto型则始终跟初始定义保持一致。因此在最外层定义的静态型变量在任何函数内更改都有效。最外层定义的静态型变量的值与全局变量的唯一差别就是不能跨文件使用。
    
11. 在return语句可以不带表达式部分，即：return;

12. C语言的函数中不是必需要有return语句，没有return语句的C函数，程序控制到达包围函数的下面大括号}时，自动返回调用函数。因此int main甚至不需要return也能运行而且没有任何报错。

## 五、数组

1. C语言规定只逐个引用数组元素，而不能一次引用整个数组。
2. 数组名是一个地址常量，不能向它赋值，也不能对它自加自减等对变量进行操作的运算。
3. 向函数中传入一维数组时在调用时只需要写一个数组名，但在参数表内要写成`int a[]`。
4. 冒泡排序外面n-1内部n-i-1。（均从0开始，小于号）

## 六（1）、指针
1. 只有基类型相同的指针之间才能相互赋值。即指向char和指向int的两个指针不能互相赋值。
2. 普通变量经过取地址运算后相当于得到一个常量指针，与一维数组名类似。
3. 指针也分局部和全局，内部和外部。
4. 不要把一个整型量赋给一个指针变量。
5. 可以把已定向的各种类型指针直接赋给void型指针。
6. 取内容运算符 `*`操作对象必须是地址表达式，即指针（地址常量或指针变量）。
7. 必须用被引用变量的地址给指针变量赋值（或用指针变量初始化方式），使指针指向确定的目标对象，然后才能使用指针来引用变量。即直接`int *p,a;`后再直接`*p=a;`是不行的，一定要`p=&a;`。
8. NULL是一个宏，是C语言中的保留值，空指针指的是指针变量指向NULL，空指针表明指针指向的地址是不可读取也不可以写入的，对其解引用是非法的。不能对NULL指针指向的地方赋值。
9. 将未初始化的指针和释放指向内存空间的指针赋值为NULL，防止意外操作野指针。
10. `void *`为通用指针，指向的内存可以存放任意类型的数据，因此程序不知道是什么类型，需要使用时应强制类型转换。
11. 指针运算：p+n即得到指向p所指对象之后第n个对象的指针，地址值为(p)±n×sizeof(数据
类型)（字节）。（前提：指针指向一片连续的储存单元。
12. 指针运算：p++即得到指向p所指对象之后一个对象的指针，地址值是：(p1)±sizeof(数据类
型)（字节）。p--同理。
13. `y=*p++;`即将p所指对象的值给y后p指向下一个对象。
14. 指针运算：p1-p2得到两个指针地址值的差值，除以sizeof()即可得到间隔了多少数据。

## 六（2）、指针
1. 数组元素的引用方式：`a[1]`或`*(a+1)`等效。
2. 在用`*(a+i)`的方式引用数组元素时还可以对指针再加一个下标，但应注意下标的具体指向。
3. a[0]是一维数组名，它是一维数组中起始元素的地址，a是二维数组名，它是二维数组的首行起始地址，二者的纯地址是相同的，即2000，但它们的基类型不同，即它们指向的数据的类型不同，前者是整型数据，后者是一维数组。![image-20210110211629503](C:\Users\62728\AppData\Roaming\Typora\typora-user-images\image-20210110211629503.png)

4. `a[i][j]`可表示为`*(a[i]+j)`。
5. 可以用一个指针去遍历整个二位数组，只要指向第一个元素不停+1并算好偏移最终位置即可。
6. 另一种方法是将指针的基类型定义为一个一维数组，即`int (*p)[4];`。但此时p只能指向数组头部。并用`p=a`将其指向二维数组的第一行，并用`*(*(p+i)+j)`来进行调用。当然也可以用在一维数组上，`(*p)[i]`即可取值。
7. 将一个二维数组a传入函数时如果要当整个二维数组用则传`*a`，取其中的一行则传`a[i]`。参数表写`*p`。函数内部直接当做一个一位数组处理，用`a[i]`取值。

## 六（3）、指针
1. 指针数组：指针的集合，每一个元素都是一个指针变量。定义：`int *p[2];`。

2. 指针数组可用于处理多维数组。![image-20210110214845266](C:\Users\62728\AppData\Roaming\Typora\typora-user-images\image-20210110214845266.png)

   在用指针数组遍历时用`*p[i]`取数据，并用`p[i]++`来指向二维数组同一行的下一个数据。

3. 经常用二级指针来处理指针数组。
![image-20210110215626047](C:\Users\62728\AppData\Roaming\Typora\typora-user-images\image-20210110215626047.png)
处理时将指针数组作为行的映射，用`*(*(p+i)+j)`来调用。
4. ![image-20210110220425459](C:\Users\62728\AppData\Roaming\Typora\typora-user-images\image-20210110220425459.png)
5. 返回指针的函数：当函数的返回值是地址时，该函数就是指针型函数。函数体内须有return语句，其后跟随的表达式结果值可以是变量的地址、数组首地址、已经定向的指针变量、结构变量地址、结构数组的首地址等这些变量和数组须是全局或静态型，不能把被调用函数内的自动变量的地址和自动型数组的首地址作为指针函数的返回值。
6. 指向函数的指针：函数的函数名和数组相似，函数名表示该函数的存储首地址，即函数的执行入口地址。函数和指向它的函数指针应具有相同的数据类型，否则，应该采用强制类型转换，两者的形参表必须完全相同。使用例子：`float (*p)(float a);`。函数指针代替函数名的调用语句一般格式：`(*函数指针名)(参数表);`或`函数指针名(参数表);`。
7. 常量指针表示指针指向的数据是被const修饰的变量const 指针类型 * 指针变量名指针类型 const * 指针变量名表明该指针指向的数据是只读的，不允许通过该指针修改指向变量的值，而指针变量可以指向其他对象——指向常量的指针。
8. 指针指向的地址不允许被修改：指针变量类型 * const 指针变量名const放在指针变量名称前，修饰的是指针变量，指针变量的值不能被更改，但指针变量指向的内存空间的数据可以被更改——指针指向常量地址。
9. 不能修改指针的指向，并且不能通过当前指针修改变量的值const 指针变量类型 * const 指针变量。

## 七、字符串
1. 一般用数值型数字表示数字的变量占用较小的内存。
2. `char *str="CHINA";`。
3. 字符数组赋值时可以一个一个用单引号加入单个字符并在最后特别写上'\0'，也可以像指针形式一样双引号直接赋值。后者会自动加'\0'。
4. 二维字符数组的初始化方式：可以双引号套多个字符串并用逗号隔开，也可以用scanf读入string[i]中一个字符串一起读入。
5. 字符串常量可以直接赋给一个指针。`char *p;p="abc";`。
6. ![image-20210110222835054](C:\Users\62728\AppData\Roaming\Typora\typora-user-images\image-20210110222835054.png)
7. gets函数用于字符串输入，例：`gets(s);`放入一个字符数组，puts函数用于字符串输出，例：`puts(s);`。
8. strcpy函数将指针src所指向的字符串复制到指针dest所指向的内存区域中，函数返回dest所指向的字符串的首地址。会覆盖原有内容。
9. strcmp函数会比较两个字符串的ASCII码值，如果第一个大则返回一个正数，小则返回一个负数。从头开始比较直到出现一个不同的字符为止。
10. strstr函数：这个函数在s1中查找整个s2第一次出现的起始位置，并返回一个指向该位置的指针。如果s2并没有完整地出现在s1的任何地方，函数将返回一个NULL指针。如果第二个参数是一个空字符串，函数就返回s1。

## 八（1）、结构和联合
懒得打了。

## 八（2）、结构和联合
懒得打了。
